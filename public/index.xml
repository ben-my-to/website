<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jason Duong</title>
    <link>https://michaelneuper.github.io/hugo-texify3/</link>
    <description>Recent content on Jason Duong</description>
    <generator>Hugo</generator>
    <language>en</language>
    <managingEditor>duongjason11@gmail.com (Jason Duong)</managingEditor>
    <webMaster>duongjason11@gmail.com (Jason Duong)</webMaster>
    <atom:link href="https://michaelneuper.github.io/hugo-texify3/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Nintendo DS Reverse Engineering</title>
      <link>https://michaelneuper.github.io/hugo-texify3/posts/nds-reverse-engineering/</link>
      <pubDate>Sat, 20 Jul 2024 00:00:00 +0000</pubDate><author>duongjason11@gmail.com (Jason Duong)</author>
      <guid>https://michaelneuper.github.io/hugo-texify3/posts/nds-reverse-engineering/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;I do not support piracy. What I provide in this article is entirely for &lt;strong&gt;educational purposes&lt;/strong&gt; only.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;intro&#34;&gt;Intro&lt;/h2&gt;&#xA;&lt;img src=&#34;https://raw.githubusercontent.com/jasonduong11/portme/main/static/images/game.png&#34; alt=&#34;game&#34;&gt;&#xA;&lt;p&gt;My first gaming console was the &lt;em&gt;Nintendo DS&lt;/em&gt;, and one of my nostalgic games, besides &lt;em&gt;Pokémon&lt;/em&gt;, was &lt;a href=&#34;https://spectrobes.fandom.com/wiki/Spectrobes_Beyond_the_Portals&#34;&gt;&lt;em&gt;Spectrobes - Beyond the Portal&lt;/em&gt;&lt;/a&gt;.&#xA;The game features mechanics similar to &lt;em&gt;Pokémon&lt;/em&gt;, with a collection of spectrobes. What differentiates them is their combat system. &lt;em&gt;Pokémon&lt;/em&gt; is turn-based, while &lt;em&gt;Spectrobes - Beyond the Portal&lt;/em&gt; is third-person.&lt;/p&gt;&#xA;&lt;p&gt;As with &lt;em&gt;Pokémon&lt;/em&gt;, spectrobes level up through experience points (XP) through battling; however, most of their XP&amp;rsquo;s come from &lt;em&gt;minerals&lt;/em&gt;. Spectrobes gain more XP if fed minerals of their type and larger size. Anyone who has played this game knows the struggle of farming/grinding minerals (especially during the swamp area).&lt;/p&gt;</description>
    </item>
    <item>
      <title>A Parallel Decision Tree Classifier</title>
      <link>https://michaelneuper.github.io/hugo-texify3/posts/mpitree-project/</link>
      <pubDate>Tue, 16 May 2023 00:00:00 +0000</pubDate><author>duongjason11@gmail.com (Jason Duong)</author>
      <guid>https://michaelneuper.github.io/hugo-texify3/posts/mpitree-project/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/jasonduong11/mpitree&#34;&gt;Link to Source Code&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;try-it-out1&#34;&gt;Try it Out!&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/h2&gt;&#xA;&lt;iframe width=&#34;803.5&#34; height=&#34;445.5&#34; src=&#34;https://editor.p5js.org/ben-my-to/full/BhAJPmrSD&#34;&gt;&lt;/iframe&gt;&#xA;&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;A &lt;strong&gt;Decision Tree&lt;/strong&gt; is an $n$-nary tree where each node represents a feature &lt;em&gt;(interior nodes)&lt;/em&gt; or response &lt;em&gt;(terminal/leaf nodes)&lt;/em&gt; value, and each branch represents a condition on some feature. Decision Trees are intuitive &lt;em&gt;supervised&lt;/em&gt; machine learning algorithms for classification and regression problems. Decision Trees behave by posing questions about the data to narrow their choices until they are somewhat confident in their predictions. The fundamental procedure for a decision tree involves recursively querying each feature and partitioning the dataset and feature space into disjoint subsets and regions until there is no ambiguity about the response variable. The primary goal of any machine learning model is &lt;em&gt;generalization&lt;/em&gt; &amp;ndash; the model&amp;rsquo;s ability to perform well on future, unseen data. Therefore, the general approach to learning an optimal decision tree involves asking &amp;ldquo;good&amp;rdquo; questions &lt;em&gt;(the features that maximize the information gain&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;)&lt;/em&gt; about the data that leads to the most certainty about the response variable each time.&lt;/p&gt;</description>
    </item>
    <item>
      <title>An Algorithm Vizualizer</title>
      <link>https://michaelneuper.github.io/hugo-texify3/posts/algorithm-vizualizer-project/</link>
      <pubDate>Sat, 09 Apr 2022 00:00:00 +0000</pubDate><author>duongjason11@gmail.com (Jason Duong)</author>
      <guid>https://michaelneuper.github.io/hugo-texify3/posts/algorithm-vizualizer-project/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/duong-jason/binary-bros&#34;&gt;Link to Source Code&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;figma-design-prototypes&#34;&gt;Figma Design Prototypes&lt;/h2&gt;&#xA;&lt;iframe style=&#34;border: 1px solid rgba(0, 0, 0, 0.1);&#34; width=&#34;800&#34; height=&#34;450&#34; src=&#34;https://www.figma.com/embed?embed_host=share&amp;url=https%3A%2F%2Fwww.figma.com%2Ffile%2FqihsKn3iY99zQqTtMatn8Z%2FLanding-Page%3Ftype%3Ddesign%26node-id%3D0%253A1%26mode%3Ddesign%26t%3DsFSbak2BwHFp1aCv-1&#34; allowfullscreen&gt;&lt;/iframe&gt;&#xA;&lt;h2 id=&#34;user-stories-and-burndown-chart&#34;&gt;User Stories and Burndown Chart&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://docs.google.com/spreadsheets/d/e/2PACX-1vSezwps9xOk-6Rl4cwyeZoJpvOKecQbakP0JX81jdKlUagxcm1o8KkY7ZCbAMgxGEtCDveL_jR8fIJe/pubhtml&#34;&gt;Link to Google Sheets&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;stand-up-meetings-and-retrospectives&#34;&gt;Stand Up Meetings and Retrospectives&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://docs.google.com/document/d/e/2PACX-1vRfUL42RWWhExU_IpmiscmZg4CCbbjoyhtOksWm0N43jliuOSuNtscRxw2rztDo3DzcLAs7UOS1FAfC/pub&#34;&gt;Link to Google Docs&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Blackjack Game Simulator</title>
      <link>https://michaelneuper.github.io/hugo-texify3/posts/blackjack-game-project/</link>
      <pubDate>Sat, 09 Apr 2022 00:00:00 +0000</pubDate><author>duongjason11@gmail.com (Jason Duong)</author>
      <guid>https://michaelneuper.github.io/hugo-texify3/posts/blackjack-game-project/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/jasonduong11/CPSC-386/tree/main/projects/blackjack&#34;&gt;Link to Source Code&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;Blackjack&lt;/strong&gt; is a casino banking game where players compete against the house or casino to obtain the best hand of cards. Unlike many other familiar card games, the players do not compete against each other or collaborate. The game is played using one or more decks of common playing cards, also known as French decks.&lt;/p&gt;&#xA;&lt;p&gt;In the game, the dealer represents the house/bank/casino. There must be at least one player. The dealer shuffles 8 decks of cards and cuts the deck. A &lt;em&gt;cut card&lt;/em&gt; is placed randomly between the 60th and 80th card from the bottom of the deck. All the cards are placed in a &lt;a href=&#34;https://en.wikipedia.org/wiki/Shoe_(cards)&#34;&gt;&lt;em&gt;shoe&lt;/em&gt;&lt;/a&gt; which the dealer uses to deal cards one at a time. When the dealer reaches the &lt;em&gt;cut card&lt;/em&gt;, then, when the game ends, the cards are shuffled, cut, a &lt;em&gt;cut card&lt;/em&gt; is placed and the cards are returned to the &lt;em&gt;shoe&lt;/em&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Larks Ant</title>
      <link>https://michaelneuper.github.io/hugo-texify3/posts/larks-ant-project/</link>
      <pubDate>Sat, 25 Sep 2021 00:00:00 +0000</pubDate><author>duongjason11@gmail.com (Jason Duong)</author>
      <guid>https://michaelneuper.github.io/hugo-texify3/posts/larks-ant-project/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/jasonduong11/CPSC-335/tree/main/Project%201&#34;&gt;Link to Source Code&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;online-demo1&#34;&gt;Online Demo&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/h2&gt;&#xA;&lt;p&gt;$q$ = &lt;output id=&#34;qt&#34;&gt;&lt;/output&gt;&lt;br&gt;&#xA;$T_{ij}$ = &lt;output id=&#34;tij&#34;&gt;&lt;/output&gt;&lt;br&gt;&#xA;$\theta$ = &lt;output id=&#34;theta&#34;&gt;&lt;/output&gt;&lt;br&gt;&#xA;$\text{counter}$ = &lt;output id=&#34;counter&#34;&gt;&lt;/output&gt;&lt;/p&gt;&#xA;&lt;figure&gt;&#xA;    &lt;canvas width=&#34;800&#34; height=&#34;400&#34; id=&#34;game&#34;&gt;&lt;/canvas&gt;&lt;br&gt;&#xA;    &lt;figurecaption&gt;Fig. 1: Larks Ant Demo&lt;/figurecaption&gt;&#xA;&lt;/figure&gt;&#xA;&lt;script type=&#34;text/javascript&#34;&gt;&#xA;var canvas = document.getElementById(&#34;game&#34;);&#xA;var context = canvas.getContext(&#34;2d&#34;);&#xA;context.strokeStyle = &#34;black&#34;;&#xA;var count = 0;&#xA;&#xA;var qt = document.getElementById(&#34;qt&#34;);&#xA;var tij = document.getElementById(&#34;tij&#34;);&#xA;var theta = document.getElementById(&#34;theta&#34;);&#xA;var c = document.getElementById(&#34;counter&#34;);&#xA;&#xA;const r_states = [&#34;Normal&#34;, &#34;Countdown&#34;];&#xA;const r_colors = [&#34;Black&#34;, &#34;Blue&#34;, &#34;Yellow&#34;, &#34;Red&#34;];&#xA;const colors = [&#34;#000000&#34;, &#34;#89CFF0&#34;, &#34;#FFF300&#34;, &#34;#FF6347&#34;];&#xA;const nose = [&#34;N&#34;, &#34;W&#34;, &#34;S&#34;, &#34;E&#34;];&#xA;const action = [0, 1, 2, 1];&#xA;&#xA;class Board {&#xA;  constructor(cell, width, height) {&#xA;    this.cell = cell;&#xA;    this.width = width;&#xA;    this.height = height;&#xA;    this.pixel = new Map();&#xA;  }&#xA;&#xA;  increment_color() {&#xA;    let pos = &#34;@&#34; + ant.x + ant.y;&#xA;    if (this.pixel.has(pos)) {&#xA;      this.pixel.set(pos, (board.pixel.get(pos) + 1) % 4);&#xA;    } else {&#xA;      this.pixel.set(pos, 1);&#xA;    }&#xA;&#xA;    context.fillStyle = colors[board.pixel.get(pos)];&#xA;    context.strokeRect(ant.x, ant.y, this.cell, this.cell);&#xA;    context.fillRect(ant.x, ant.y, this.cell, this.cell);&#xA;  }&#xA;&#xA;  get_color(pos) {&#xA;    return board.pixel.has(pos) ? board.pixel.get(pos) : 0;&#xA;  }&#xA;}&#xA;&#xA;class Ant {&#xA;  constructor(x, y, state, nose, counter) {&#xA;    this.x = x;&#xA;    this.y = y;&#xA;    this.state = state;&#xA;    this.nose = nose;&#xA;    this.counter = counter;&#xA;  }&#xA;&#xA;  fsm(action) {&#xA;    let transition;&#xA;    this.counter = board.get_color(&#34;@&#34; + ant.x + ant.y);&#xA;&#xA;    if (this.state == 0) {&#xA;      if (action == 0) {&#xA;        theta.innerHTML = &#34;Left&#34;;&#xA;        ant.nose = ++ant.nose % 4;&#xA;      }&#xA;      else if (action == 1) {&#xA;        theta.innerHTML = &#34;Right&#34;;&#xA;        if (ant.nose == 0)&#xA;          ant.nose = 3;&#xA;        else&#xA;          ant.nose--;&#xA;      }&#xA;      else {&#xA;        theta.innerHTML = &#34;Straight&#34;;&#xA;        this.state = 1;&#xA;      }&#xA;    }&#xA;    else {&#xA;      if (this.counter &lt;= 0) {&#xA;        this.state = 0;&#xA;      } else {&#xA;        this.counter--;&#xA;      }&#xA;    }&#xA;  }&#xA;&#xA;  move() {&#xA;    let dx = this.x;&#xA;    let dy = this.y;&#xA;    let size = board.cell;&#xA;    let max_width = board.width * size;&#xA;    let max_height = board.height * size;&#xA;&#xA;    switch (nose[ant.nose]) {&#xA;      case &#34;N&#34;: {&#xA;        dy = (dy == 0 ? max_height : dy) - size;&#xA;        break;&#xA;      }&#xA;      case &#34;W&#34;: {&#xA;        dx = (dx == 0 ? max_width : dx) - size;&#xA;        break;&#xA;      }&#xA;      case &#34;S&#34;: {&#xA;        dy = (dy + size) % max_height;&#xA;        break;&#xA;      }&#xA;      case &#34;E&#34;: {&#xA;        dx = (dx + size) % max_width;&#xA;      }&#xA;    }&#xA;&#xA;    this.x = dx; // move ant in x-dir&#xA;    this.y = dy; // move ant in y-dir&#xA;  }&#xA;}&#xA;&#xA;const board = new Board(10, 80, 40);&#xA;const ant = new Ant(400, 200, 0, 0, 0);&#xA;&#xA;var halt = false;&#xA;var speed = 60;&#xA;&#xA;function update() {&#xA;  qt.innerHTML = r_states[ant.state];&#xA;  tij.innerHTML = r_colors[board.get_color(&#34;@&#34; + ant.x + ant.y)];&#xA;  c.innerHTML = ant.counter;&#xA;  ant.fsm(action[board.get_color(&#34;@&#34; + ant.x + ant.y)]);&#xA;  board.increment_color();&#xA;  ant.move();&#xA;}&#xA;&#xA;function loop() {&#xA;  requestAnimationFrame(loop);&#xA;  if (++count &lt; speed) return;&#xA;  if (!halt) {&#xA;    update();&#xA;  }&#xA;  count = 0;&#xA;}&#xA;&#xA;document.addEventListener(&#34;keydown&#34;, (e) =&gt; {&#xA;  switch (e.which) {&#xA;    case 72:&#xA;      halt = !halt;&#xA;      break;&#xA;    case 65:&#xA;      speed = Math.max(1, speed - 10);&#xA;      break;&#xA;    case 68:&#xA;      speed = Math.min(60, speed + 10);&#xA;      break;&#xA;  }&#xA;});&#xA;&#xA;requestAnimationFrame(loop);&#xA;&lt;/script&gt;&#xA;&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;div class=&#34;definition&#34;&gt;&#xA;&lt;p&gt;&lt;strong&gt;Definition 1&lt;/strong&gt;: &lt;em&gt;Larks Ant&lt;/em&gt; is a 2D cellular automaton $\mathcal{A}$ that consists of a pair set of states $\mathbf{Q}$, a quadruple of colors $\Sigma$, an initial state $q_0\in\mathbf{Q}$, a local variable $\text{counter}$, and a transition function $\delta_\mathcal{A}:\mathbf{Q}\times\Sigma\to\mathbf{Q}\times\Sigma\times\theta$ where&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
